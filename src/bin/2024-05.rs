use std::fs; // Import the file system module
use std::collections::HashSet; // Import HashSet for fast rule lookups
use std::cmp::Ordering;

// Code generated by gemini-3-pro-review 

fn main() {
    // 1. Read the input file into a single String
    let input = fs::read_to_string("data/2024/05/input.txt")
        .expect("Should have been able to read the file");

    // 2. Separate the Rules from the Updates
    // The input has two sections separated by a double newline ("\n\n").
    // unwrap() is used here because we assume the input is valid and has two sections.
    let (rules_section, updates_section) = input.split_once("\n\n").unwrap();

    // 3. Parse the Rules
    // We want to store pairs of (X, Y) where X|Y is a rule.
    // HashSet is great here because checking `contains` is very fast.
    let mut rules: HashSet<(u32, u32)> = HashSet::new();

    for line in rules_section.lines() {
        if line.trim().is_empty() { continue; }
        
        // Split "47|53" into "47" and "53"
        let (left, right) = line.split_once('|').unwrap();
        
        // Parse strings into unsigned 32-bit integers
        let a: u32 = left.trim().parse().unwrap();
        let b: u32 = right.trim().parse().unwrap();
        
        // Insert the pair into our set
        rules.insert((a, b));
    }

    // 4. Parse the Updates
    // We want a list of lists: Vec<Vec<u32>>
    let mut updates: Vec<Vec<u32>> = Vec::new();

    for line in updates_section.lines() {
        if line.trim().is_empty() { continue; }
        
        // Parse "75,47,61" into a Vector of numbers
        let update: Vec<u32> = line
            .split(',')
            .map(|s| s.trim().parse().unwrap())
            .collect();
            
        updates.push(update);
    }

    // 5. Check Validity and Sum Middles
    let mut total_middle_sum = 0;

    // Iterate through each update (we borrow it using &update so we don't move ownership)
    for update in &updates {
        if is_update_valid(update, &rules) {
            // Find the middle index. 
            // For length 5, index is 2 (0, 1, [2], 3, 4). Integer division 5/2 = 2.
            let middle_index = update.len() / 2;
            let middle_page = update[middle_index];
            
            total_middle_sum += middle_page;
        }
    }

    println!("Part 1 Answer: {}", total_middle_sum);


    // 2. Check Density
    println!("Checking rule density for {} updates...", updates.len());
    
    for (i, update) in updates.iter().enumerate() {
        let n = update.len();
        // Total unique pairs in a list of size n is: n * (n-1) / 2
        let total_pairs = n * (n - 1) / 2;
        let mut connected_pairs = 0;

        // Check every pair (x, y)
        for j in 0..n {
            for k in (j + 1)..n {
                let a = update[j];
                let b = update[k];

                // Check if DIRECT rule exists (a|b OR b|a)
                if rules.contains(&(a, b)) || rules.contains(&(b, a)) {
                    connected_pairs += 1;
                }
            }
        }

        if connected_pairs < total_pairs {
            println!(
                "Update {}: Partial Density! Found {}/{} rules.", 
                i, connected_pairs, total_pairs
            );
        }
    }
    println!("Finished checking density. If no warnings appeared, density is 100%.");

    // --- 2. Logic for Part 2 ---
    let mut total_fixed_middle_sum = 0;

    for update in &updates {
        // We only care about INVALID updates for Part 2
        if !is_update_valid(update, &rules) {
            
            // Create a mutable copy so we can sort it
            let mut fixed_update = update.clone();

            // Sort the update based on the rules
            // sort_by expects us to return an Ordering (Less, Greater, or Equal)
            fixed_update.sort_by(|a, b| {
                // Check if there is a rule saying 'a' must be before 'b' (a|b)
                if rules.contains(&(*a, *b)) {
                    return Ordering::Less;
                }
                // Check if there is a rule saying 'b' must be before 'a' (b|a)
                if rules.contains(&(*b, *a)) {
                    return Ordering::Greater;
                }
                
                // If no rule exists between them, they are equal
                Ordering::Equal
            });

            // Find the middle of the NOW SORTED update
            let middle_index = fixed_update.len() / 2;
            total_fixed_middle_sum += fixed_update[middle_index];
        }
    }

    println!("Part 2 Answer: {}", total_fixed_middle_sum);
}

// Function to check if a specific update follows all rules
// We pass `update` as a slice (&[u32]) because we just need to read it.
// We pass `rules` as a reference to the HashSet.
fn is_update_valid(update: &[u32], rules: &HashSet<(u32, u32)>) -> bool {
    
    // We need to look at every pair of pages (a, b) where 'a' appears before 'b'
    // in the update.
    for i in 0..update.len() {
        for j in (i + 1)..update.len() {
            let page_a = update[i]; // The page that appears earlier
            let page_b = update[j]; // The page that appears later

            // The update says `page_a` comes before `page_b`.
            // This is INVALID if there is a rule saying `page_b` MUST be before `page_a`.
            // That rule would look like: page_b|page_a.
            
            if rules.contains(&(page_b, page_a)) {
                // We found a rule saying B must be before A, 
                // but in our list A is before B. Violation!
                return false;
            }
        }
    }
    
    // If we checked all pairs and found no violations, it is valid.
    true
}