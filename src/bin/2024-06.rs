use std::collections::HashSet;
use std::fs;

// Code generated by gemini-3-pro-review 

// 1. DEFINING DIRECTION
// We create a custom type (Enum) for the 4 directions.
// #[derive(...)] automatically generates code so we can compare (PartialEq, Eq),
// copy (Clone, Copy), and use in a HashSet (Hash) these values.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum Direction {
    Up,
    Right,
    Down,
    Left,
}

impl Direction {
    // A helper method to get the next direction when turning 90 degrees right
    fn turn_right(self) -> Self {
        match self {
            Direction::Up => Direction::Right,
            Direction::Right => Direction::Down,
            Direction::Down => Direction::Left,
            Direction::Left => Direction::Up,
        }
    }

    // A helper to get the change in (row, col) for this direction
    fn delta(self) -> (i32, i32) {
        match self {
            Direction::Up => (-1, 0),   // Decrease row index to go up
            Direction::Right => (0, 1), // Increase col index to go right
            Direction::Down => (1, 0),  // Increase row index to go down
            Direction::Left => (0, -1), // Decrease col index to go left
        }
    }
}

fn main() {
    // 2. READING INPUT
    // We read the file into a string.
    // Note: Use a raw string literal or double backslashes for Windows paths if needed.
    // Ideally, save your input as "input.txt" in the project folder.
    let input = fs::read_to_string("data/2024/06/input.txt").expect("Should have been able to read the file");

    // Parse the input into a 2D grid (Vector of Vectors of characters)
    let mut grid: Vec<Vec<char>> = input
        .lines()
        .map(|line| line.chars().collect())
        .collect();

    // 3. FINDING START POSITION
    let mut start_pos = (0, 0);
    let start_dir = Direction::Up; // Problem states guard starts facing ^ (Up)

    // Iterate through rows and cols to find '^'
    for (r, row) in grid.iter().enumerate() {
        for (c, &ch) in row.iter().enumerate() {
            if ch == '^' {
                // We cast to i32 because coordinate math might temporarily go negative
                start_pos = (r as i32, c as i32);
            }
        }
    }

    // --- PART 1 ---
    println!("--- Part 1 ---");
    
    // We run the simulation to get all visited positions.
    // We return a HashSet of (row, col) tuples.
    // We pass a clone of the grid because we don't want to modify the original yet,
    // though for Part 1 specifically, we don't modify it anyway.
    let (visited_positions, _is_loop) = simulate_path(&grid, start_pos, start_dir);
    
    println!("Distinct positions visited: {}", visited_positions.len());

    // --- PART 2 ---
    println!("\n--- Part 2 ---");

    let mut loop_count = 0;

    // We only need to try placing obstacles on the path the guard actually took.
    // Putting an obstacle where the guard never goes won't change anything.
    // We iterate through every unique position visited in Part 1.
    for pos in visited_positions.iter() {
        let (r, c) = *pos;

        // We cannot place an obstacle at the starting position
        if (r, c) == start_pos {
            continue;
        }

        // 1. Place a temporary obstacle
        // We need to cast back to usize to index into the vector
        let grid_r = r as usize;
        let grid_c = c as usize;
        
        // Save the original character (it should be '.', but let's be safe)
        let original_char = grid[grid_r][grid_c];
        grid[grid_r][grid_c] = '#';

        // 2. Run the simulation
        let (_, is_loop) = simulate_path(&grid, start_pos, start_dir);

        // 3. Check result
        if is_loop {
            loop_count += 1;
        }

        // 4. Revert the change (Backtracking)
        grid[grid_r][grid_c] = original_char;
    }

    println!("Possible obstruction positions for loops: {}", loop_count);
}

// A generic function to run the guard simulation.
// Returns:
// 1. A HashSet of all (row, col) positions visited.
// 2. A boolean: true if a loop was detected, false if the guard left the map.
fn simulate_path(
    grid: &Vec<Vec<char>>, 
    start: (i32, i32), 
    mut dir: Direction
) -> (HashSet<(i32, i32)>, bool) {
    
    let rows = grid.len() as i32;
    let cols = grid[0].len() as i32;

    let mut current_pos = start;
    
    // For Part 1: Track unique coordinates
    let mut visited_coords = HashSet::new();
    visited_coords.insert(current_pos);

    // For Part 2 (Loop Detection): Track (coordinate + direction) states.
    // If we are at (5,5) facing UP, and later return to (5,5) facing UP, we are looping.
    let mut visited_states = HashSet::new();
    visited_states.insert((current_pos, dir));

    loop {
        // Calculate the position directly in front
        let (dr, dc) = dir.delta();
        let next_r = current_pos.0 + dr;
        let next_c = current_pos.1 + dc;

        // Check if next step is out of bounds (Guard leaves map)
        if next_r < 0 || next_r >= rows || next_c < 0 || next_c >= cols {
            return (visited_coords, false); // False = Not a loop
        }

        // Check what is at the next position
        // We cast to usize for indexing
        let next_char = grid[next_r as usize][next_c as usize];

        if next_char == '#' {
            // OBSTACLE: Turn right. Do NOT move yet.
            dir = dir.turn_right();
        } else {
            // EMPTY SPACE (or start marker): Move forward.
            current_pos = (next_r, next_c);
            visited_coords.insert(current_pos);
        }

        // LOOP CHECK:
        // Have we been in this exact position facing this exact direction before?
        if visited_states.contains(&(current_pos, dir)) {
            return (visited_coords, true); // True = Loop detected
        }
        
        // Record the current state
        visited_states.insert((current_pos, dir));
    }
}